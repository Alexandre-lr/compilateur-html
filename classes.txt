#pragma once
#include <memory>
#include "contexte.hh"

class Contexte;

class Noeud
{
public:
    virtual std::string to_html(const Contexte & contexte) const =0;
};

using NoeudPtr = std::shared_ptr<Noeud>;


#pragma once
#include <fstream>
#include "noeud.hh"

class Page : public Noeud
{
public:
    Page(NoeudPtr corps, NoeudPtr entete);
    Page(const Page &) =default;

    std::string to_html(const Contexte & contexte) const override;

    void sauvegarder(const std::string & dest, const Contexte & contexte) const;
private:
    NoeudPtr _corps;
    NoeudPtr _entete;
};


#pragma once
#include "noeud.hh"
#include "propriete.hh"

class NoeudEnTete : public Noeud
{
public:
    NoeudEnTete();
    NoeudEnTete(const NoeudEnTete &) =default;

    std::string to_html(const Contexte & contexte) const override;

    const NoeudPtr & langue() const;
    void modifier_propriete(NoeudPtr propriete);
    void modifier_titre(NoeudPtr titre);
private:
    std::map<Propriete_t, NoeudPtr> _proprietes;
    NoeudPtr _titre;
};


#pragma once
#include <vector>
#include "noeud.hh"

class NoeudCorps : public Noeud
{
public:
    NoeudCorps() =default;
    NoeudCorps(const NoeudCorps &) =default;

    std::string to_html(const Contexte & contexte) const override;

    NoeudPtr& element(const std::size_t & idx, const std::string & balise);

    void ajouter_element(NoeudPtr element);
    void ajouter_attribut(NoeudPtr style, std::string type);
private:
    mutable std::vector<NoeudPtr> _elements;
    mutable bool _fini = false;
    std::map<std::string, NoeudPtr> _styles;

    void regrouper_commentaires(const Contexte & contexte) const;
    void appliquer_styles() const;
    void finaliser_html(const Contexte & contexte) const;
};


#pragma once
#include "noeud.hh"

class NoeudElement : public Noeud
{
public:
    NoeudElement() =delete;
    NoeudElement(const NoeudElement &) =default;
    NoeudElement(const NoeudPtr & contenu);

    virtual std::string nom_balise() const =0;
    NoeudPtr contenu() const;
private:
    NoeudPtr _contenu;
};


#pragma once
#include <string>
#include <vector>
#include "noeudElement.hh"
#include "attribut.hh"

class BaliseStyle : public NoeudElement
{
public:
    BaliseStyle() =delete;
    BaliseStyle(const BaliseStyle &) =default;
    BaliseStyle(NoeudPtr contenu, NoeudPtr style);

    std::string to_html(const Contexte & contexte) const override;

    // Déclaration d'opérateur personnalisé
    NoeudPtr& style();
    NoeudPtr& attribut(Attribut_t attribut);

    // Modifie seulement l'attribut, ne le retourne pas
    void modifier_attribut(NoeudPtr attribut);
private:
    NoeudPtr _style;
};


#pragma once
#include <cstdint>
#include "baliseStyle.hh"

class BaliseTitre : public BaliseStyle
{
public:
    BaliseTitre() =delete;
    BaliseTitre(const BaliseTitre &) =default;
    BaliseTitre(NoeudPtr text, NoeudPtr style, const std::uint8_t & niveau);

    std::string nom_balise() const override;
private:
    std::uint8_t _niveau;
};


#pragma once
#include "baliseStyle.hh"

class BaliseParagraphe : public BaliseStyle
{
public:
    BaliseParagraphe() =delete;
    BaliseParagraphe(const BaliseParagraphe &) =default;
    BaliseParagraphe(NoeudPtr text, NoeudPtr style);

    std::string nom_balise() const override;
};


#pragma once
#include "noeudElement.hh"

class BaliseImage : public NoeudElement
{
public:
    BaliseImage() =delete;
    BaliseImage(const BaliseImage &) =default;
    BaliseImage(NoeudPtr src);

    std::string to_html(const Contexte & contexte) const override;

    std::string nom_balise() const override;
};


#pragma once
#include "noeudElement.hh"

class BaliseCommentaire : public NoeudElement
{
public:
    BaliseCommentaire() =delete;
    BaliseCommentaire(const BaliseCommentaire &) =default;
    BaliseCommentaire(NoeudPtr text);

    std::string to_html(const Contexte & contexte) const override;

    std::string nom_balise() const override;
};


#pragma once
#include "noeud.hh"

class Text : public Noeud
{
public:
    Text() =delete;
    Text(const Text &) =default;
    Text(std::string const & valeur);

    std::string to_html(const Contexte & contexte) const override;
private:
    std::string _valeur;
};


#pragma once
#include <string>
#include "noeud.hh"



class Variable : public Noeud
{
public:
    Variable() = delete;
    Variable(const Variable &) = default;
    Variable(const std::string & nom);

private:
    std::string _nom;
};


#pragma once
#include <algorithm>
#include "noeud.hh"
#include "attribut.hh"

class Style : public Noeud
{
public:
    Style() : _attributs(std::map<Attribut_t, NoeudPtr>()) {}
//    Style(Attribut attribut) : _attributs(std::map<Attribut_t, NoeudPtr>()) {}
    Style(const Style &) =default;

    std::string to_html(const Contexte & contexte) const override;

    // Déclaration d'opérateur personnalisé
    NoeudPtr& attribut(Attribut_t type);
    Style& operator=(const Style & s);

    void modifier_attribut(NoeudPtr attribut);
private:
    std::map<Attribut_t, NoeudPtr> _attributs;
};


#pragma once
#include "noeud.hh"

enum class Attribut_t {
    largeur,
    hauteur,
    couleurTexte,
    couleurFond,
    opacite,
};

class Attribut : public Noeud
{
public:
    Attribut() =delete;
    Attribut(const Attribut &) =default;
    Attribut(Attribut_t type, NoeudPtr valeur);

    std::string to_html(const Contexte & contexte) const override;

    Attribut& operator=(const Attribut & a);
    Attribut_t const & type() const;
private:
    Attribut_t _type;
    NoeudPtr _valeur;
};


#pragma once
#include "noeud.hh"

enum class Propriete_t {
    encodage,
    icone,
    css,
    langue,
};

class Propriete : public Noeud
{
public:
    Propriete() =delete;
    Propriete(const Propriete &) =default;
    Propriete(Propriete_t type, NoeudPtr valeur);

    std::string to_html(const Contexte & contexte) const override;

    Propriete_t const & type() const;
private:
    Propriete_t _type;
    NoeudPtr _valeur;
};


#pragma once
#include <cstdint>
#include <iomanip>
#include <string>
#include <sstream>
#include "noeud.hh"

class Couleur : public Noeud
{
public:
    Couleur() =delete;
    Couleur(const Couleur &) =default;
    Couleur(std::uint8_t const & r, std::uint8_t const & v, std::uint8_t const & b);
    Couleur(const std::string& couleurHex);

    std::string to_html(const Contexte & contexte) const override;
private:
    std::uint8_t _r;
    std::uint8_t _v;
    std::uint8_t _b;
};


#pragma once
#include "noeud.hh"

class Constante : public Noeud
{
public:
    Constante() =delete;
    Constante(const Constante &) =default;
    Constante(double valeur);

    std::string to_html(const Contexte & contexte) const;

    double valeur() const;
private:
    double _valeur;
};


#pragma once
#include <map>
#include <string>
#include "noeud.hh"

class Noeud;
using NoeudPtr = std::shared_ptr<Noeud>;
class Contexte {
private:
    std::map<std::string, NoeudPtr> variables;

public:
    Contexte() = default;
    Contexte(const Contexte& autre) = default;

    NoeudPtr& get(const std::string& nom);
    const NoeudPtr& get(const std::string& nom) const;

    NoeudPtr& operator[](const std::string& nom);
    const NoeudPtr& operator[](const std::string& nom) const;
};


#ifndef DRIVER_H
#define DRIVER_H

#include <string>

#include "contexte.hh"

class Driver {
private:
    Contexte variables;
public:
    Driver();
    ~Driver();

    const Contexte& getContexte() const;
    NoeudPtr&  getVariable(const std::string& name);
    void setVariable(const std::string& name, NoeudPtr& value);
};

#endif
